import { $, fs } from 'zx'
import {
	boundsFields,
	borderFields,
	canvasElementSchema,
	elementSchemas,
	rotationFields,
} from '../shared-lib/lib/Graphics/ElementPropertiesSchemas.ts'
import { SomeCompanionInputField } from '../shared-lib/lib/Model/Options.ts'
// import { assertNever } from '../shared-lib/lib/Util.ts'
import { capitalize, isEqual } from 'lodash-es'
import { fileURLToPath } from 'url'

let generatedFile = '/* eslint-disable */\n// This file is autogenerated by tools/generate_graphics_types.mts\n\n'
generatedFile += `import type { ExpressionOrValue } from '../Model/Expression.js'\n`
generatedFile += `import type { ButtonGraphicsElementUsage, ButtonGraphicsDecorationType, HorizontalAlignment, VerticalAlignment } from './StyleModel.js'\n`
generatedFile += '\n'

function convertFieldType(field: SomeCompanionInputField, isExpressionable: boolean): string {
	let tsType: string
	switch (field.type) {
		case 'number':
			tsType = 'number'
			break
		case 'textinput':
			tsType = 'string'
			break
		case 'checkbox':
			tsType = 'boolean'
			break
		case 'colorpicker':
			tsType = 'number'
			break
		case 'dropdown':
			if (field.allowCustom) {
				tsType = 'string'
			} else {
				tsType = field.choices.map((choice) => JSON.stringify(choice.id)).join(' | ')
			}
			break
		case 'internal:png-image':
			tsType = 'string | null'
			break
		case 'internal:horizontal-alignment':
			tsType = 'HorizontalAlignment'
			break
		case 'internal:vertical-alignment':
			tsType = 'VerticalAlignment'
			break
		default:
			// assertNever(field.type)
			throw new Error(`Unhandled field type: ${field.type}`)
	}

	if (!isExpressionable) return tsType

	return `ExpressionOrValue<${tsType}>`
}

// Generate some common/base schemas

// Generate ButtonGraphicsDrawBase interface
generatedFile += 'export interface ButtonGraphicsDrawBase {\n'
generatedFile += `\treadonly id: string\n`
// generatedFile += `\tname: string\n`
generatedFile += `\tusage: ButtonGraphicsElementUsage\n`
generatedFile += `\tenabled: boolean\n`
generatedFile += `\topacity: number\n`
generatedFile += '}\n\n'

// Generate ButtonGraphicsElementBase interface
generatedFile += 'export interface ButtonGraphicsElementBase {\n'
generatedFile += `\treadonly id: string\n`
generatedFile += `\tname: string\n`
generatedFile += `\tusage: ButtonGraphicsElementUsage\n`
generatedFile += `\tenabled: ExpressionOrValue<boolean>\n`
generatedFile += `\topacity: ExpressionOrValue<number>\n`
generatedFile += '}\n\n'

const baseInterfaceTypes = {
	bounds: boundsFields,
	border: borderFields,
	rotation: rotationFields,
}

function generateBaseInterfaceName(id: string): {
	drawName: string
	elementName: string
} {
	const capitalized = capitalize(id)
	return {
		drawName: `ButtonGraphicsDraw${capitalized}`,
		elementName: `ButtonGraphics${capitalized}`,
	}
}

for (const [id, fields] of Object.entries(baseInterfaceTypes)) {
	const { drawName, elementName } = generateBaseInterfaceName(id)

	// Generate ButtonGraphicsDrawBounds interface
	generatedFile += `export interface ${drawName} {\n`
	for (const field of fields) {
		const tsType = convertFieldType(field, false)
		generatedFile += `\t${field.id}: ${tsType}\n`
	}
	generatedFile += '}\n\n'

	// Generate ButtonGraphicsBounds interface
	generatedFile += `export interface ${elementName} {\n`
	for (const field of fields) {
		const tsType = convertFieldType(field, true)
		generatedFile += `\t${field.id}: ${tsType}\n`
	}
	generatedFile += '}\n\n'
}

// Generate the special canvas element

// Generate ButtonGraphicsCanvasDrawElement interface
generatedFile += `export interface ButtonGraphicsCanvasDrawElement extends Omit<ButtonGraphicsDrawBase, 'enabled' | 'opacity'> {\n`
generatedFile += `\t// Note: this is the background element and can only be at the bottom of the stack\n`
generatedFile += `\ttype: 'canvas'\n`
for (const field of canvasElementSchema) {
	if (field.id === 'decoration') {
		generatedFile += `\tdecoration: ButtonGraphicsDecorationType // replaces show_topbar\n`
	} else {
		const tsType = convertFieldType(field, false)
		generatedFile += `\t${field.id}: ${tsType}\n`
	}
}
generatedFile += '}\n\n'

// Generate ButtonGraphicsCanvasElement interface
generatedFile += `export interface ButtonGraphicsCanvasElement extends Omit<ButtonGraphicsElementBase, 'enabled' | 'opacity'> {\n`
generatedFile += `\t// Note: this is the background element and can only be at the bottom of the stack\n`
generatedFile += `\ttype: 'canvas'\n`
for (const field of canvasElementSchema) {
	if (field.id === 'decoration') {
		generatedFile += `\tdecoration: ExpressionOrValue<ButtonGraphicsDecorationType> // replaces show_topbar\n`
	} else {
		const tsType = convertFieldType(field, true)
		generatedFile += `\t${field.id}: ${tsType}\n`
	}
}
generatedFile += '}\n\n'

// Generate the rest of the element types

const allDrawElementTypes: string[] = ['ButtonGraphicsCanvasDrawElement']
const allElementTypes: string[] = ['ButtonGraphicsCanvasElement']

for (const [id, fields] of Object.entries(elementSchemas)) {
	if (id === 'canvas') continue // already done

	const typeName = capitalize(id)

	const drawInterfaces = ['ButtonGraphicsDrawBase']
	const elementInterfaces = ['ButtonGraphicsElementBase']

	const ignoreFields = new Set(['enabled', 'opacity'])
	for (const [id, interfaceFields] of Object.entries(baseInterfaceTypes)) {
		if (interfaceFields.every((boundsField) => fields.find((field) => isEqual(field, boundsField)))) {
			const { drawName, elementName } = generateBaseInterfaceName(id)
			drawInterfaces.push(drawName)
			elementInterfaces.push(elementName)
			for (const field of interfaceFields) ignoreFields.add(field.id)
		}
	}

	const filteredFields = fields.filter((field) => !ignoreFields.has(field.id))

	const drawElementName = `ButtonGraphics${typeName}DrawElement`
	allDrawElementTypes.push(drawElementName)
	const elementName = `ButtonGraphics${typeName}Element`
	allElementTypes.push(elementName)

	// Generate draw element interface
	generatedFile += `export interface ${drawElementName} extends ${drawInterfaces.join(', ')} {\n`
	generatedFile += `\ttype: '${id}'\n`
	for (const field of filteredFields) {
		const tsType = convertFieldType(field, false)
		generatedFile += `\t${field.id}: ${tsType}\n`
	}
	if (id === 'group') generatedFile += `\tchildren: SomeButtonGraphicsDrawElement[]\n`
	generatedFile += '}\n\n'

	// Generate raw element interface
	generatedFile += `export interface ${elementName} extends ${elementInterfaces.join(', ')} {\n`
	generatedFile += `\ttype: '${id}'\n`
	for (const field of filteredFields) {
		const tsType = convertFieldType(field, true)
		generatedFile += `\t${field.id}: ${tsType}\n`
	}
	if (id === 'group') generatedFile += `\tchildren: SomeButtonGraphicsElement[]\n`
	generatedFile += '}\n\n'
}

generatedFile += `export type SomeButtonGraphicsDrawElement =\n`
for (const typeName of allDrawElementTypes) {
	generatedFile += `\t| ${typeName}\n`
}
generatedFile += `\nexport type SomeButtonGraphicsElement =\n`
for (const typeName of allElementTypes) {
	generatedFile += `\t| ${typeName}\n`
}

const outputPath = new URL('../shared-lib/lib/Model/StyleLayersModel.ts', import.meta.url)
fs.writeFile(outputPath, generatedFile, 'utf8')

await $`prettier --write ${fileURLToPath(outputPath)}`
